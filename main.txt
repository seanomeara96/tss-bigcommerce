package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/joho/godotenv"
	"github.com/seanomeara96/go-bigcommerce"
)

type HireJob struct {
	XMLName      xml.Name  `xml:"hirejob"`
	WebEnquiryID string    `xml:"webenquiryid"`
	Email        string    `xml:"email"`
	ContactName  string    `xml:"contactname"`
	Name         string    `xml:"name"`
	Address      string    `xml:"address"`
	Postcode     string    `xml:"postcode"`
	TelNo        string    `xml:"telno"`
	DelvName     string    `xml:"delvname"`
	DelvInitials string    `xml:"delvinitials"`
	DelvAddress  string    `xml:"delvaddress"`
	DelvPostcode string    `xml:"delvpostcode"`
	DelvTelNo    string    `xml:"delvtelno"`
	StartDate    string    `xml:"startdate"`
	EndDate      string    `xml:"enddate"`
	HireItems    HireItems `xml:"hireitems"`
}

type HireItems struct {
	Items []Item `xml:"item"`
}

type Item struct {
	Code           string  `xml:"code"`
	Description    string  `xml:"description"`
	Qty            int     `xml:"qty"`
	Price          float64 `xml:"price"`
	DiscountAmount float64 `xml:"discountamount"`
	UnitPrice      float64 `xml:"unitprice"`
	VATCode        string  `xml:"vatcode"`
	Total          float64 `xml:"total"`
}

// ConvertOrderProductToItem converts an OrderProduct to an Item
func ConvertOrderProductToItem(op bigcommerce.OrderProduct) (Item, error) {
	// Parsing the required fields from strings to float64
	var err error
	basePrice, _ := strconv.ParseFloat(op.BasePrice, 64)
	totalExTax, _ := strconv.ParseFloat(op.TotalExTax, 64)
	discountAmount := 0.0
	if len(op.AppliedDiscounts) > 0 {
		discountAmount, err = strconv.ParseFloat(op.AppliedDiscounts[0].Amount, 64)
		if err != nil {
			return Item{}, err
		}
	}
	return Item{
		Code:           op.SKU,
		Description:    op.Name,
		Qty:            op.Quantity,
		Price:          basePrice,
		DiscountAmount: discountAmount,
		UnitPrice:      basePrice, // Assuming UnitPrice is the same as BasePrice
		VATCode:        "VAT",     // Placeholder as VATCode isn't provided in OrderProduct
		Total:          totalExTax,
	}, nil
}

func ConvertOrderToHireJob(startDate, endDate string, order bigcommerce.Order, shippingAddress bigcommerce.ShippingAddress, orderProducts []bigcommerce.OrderProduct) (HireJob, error) {
	items := []Item{}
	for _, p := range orderProducts {
		item, err := ConvertOrderProductToItem(p)
		if err != nil {
			return HireJob{}, err
		}
		items = append(items, item)
	}
	name := fmt.Sprintf("%s %s", order.BillingAddress.FirstName, order.BillingAddress.LastName)
	billingAddressParts := []string{order.BillingAddress.Street1, order.BillingAddress.Street2, order.BillingAddress.City, order.BillingAddress.State}
	billingAddressParts = func() (res []string) {
		for _, p := range billingAddressParts {
			if p != "" {
				res = append(res, p)
			}
		}
		return res
	}()

	shippingAddressParts := []string{shippingAddress.Street1, shippingAddress.Street2, shippingAddress.City, shippingAddress.State}
	shippingAddressParts = func() (res []string) {
		for _, p := range shippingAddressParts {
			if p != "" {
				res = append(res, p)
			}
		}
		return res
	}()

	return HireJob{
		WebEnquiryID: fmt.Sprintf("%d", order.ID),
		Email:        order.BillingAddress.Email,
		ContactName:  name,
		Name:         name,
		Address:      strings.Join(billingAddressParts, ", "),
		Postcode:     order.BillingAddress.Zip,
		TelNo:        order.BillingAddress.Phone,
		DelvName:     name,
		DelvInitials: order.BillingAddress.FirstName,
		// TODO need shipping address istead
		DelvAddress: strings.Join(shippingAddressParts, ", "),
		// TODO need shipping eircode istead
		DelvPostcode: order.BillingAddress.Zip,
		DelvTelNo:    order.BillingAddress.Phone,
		// TODO pickup date from order comment
		StartDate: startDate,
		// TODO return date from order comment
		EndDate:   endDate,
		HireItems: HireItems{Items: items},
	}, nil
}

func main() {
	if err := godotenv.Load(); err != nil {
		log.Fatal(err)
	}

	client := bigcommerce.NewClient(os.Getenv("CH_STORE_HASH"), os.Getenv("CH_XAUTHTOKEN"), 2)

	statuses, err := client.GetOrderStatuses()
	if err != nil {
		log.Fatal(err)
	}

	statusID := 11
	for _, s := range statuses {
		if s.Name == "Awaiting Fulfillment" {
			statusID = s.ID
		}
	}

	orderQueryParams := bigcommerce.OrderQueryParams{
		StatusID: statusID,
		Limit:    5,
		Sort: bigcommerce.OrderSortQuery{
			Field:     bigcommerce.OrderSortFieldID,
			Direction: bigcommerce.OrderSortDirectionDesc,
		}.String(),
	}

	orders, _, err := client.GetOrders(orderQueryParams)
	if err != nil {
		log.Fatal(err)
	}

	for _, order := range orders {

		shippingAddresses, _, err := client.GetOrderShippingAddress(order.ID, bigcommerce.ShippingAddressQueryParams{})
		if err != nil {
			log.Fatal(err)
		}

		shippingAddress := shippingAddresses[0]

		integerStringExp := regexp.MustCompile(`\*\/(.+);\/\*`)
		matches := integerStringExp.FindStringSubmatch(order.CustomerMessage)

		if len(matches) < 2 {
			// TODO wwhat do when no match???
			continue
		}

		integerString := matches[1]

		deliveryDateExp := regexp.MustCompile(`Delivery\sDate\s=\s(\w+,\s\w+\s\d{1,2},\s\d{4})`)
		//eventDateExp := regexp.MustCompile(`Event\sDate\s=\s(\w+,\s\w+\s\d{1,2},\s\d{4})`)
		collectionDateExp := regexp.MustCompile(`Collection\sDate\s=\s(\w+,\s\w+\s\d{1,2},\s\d{4})`)

		pickupDateExp := regexp.MustCompile(`Pickup\sDate\s=\s(\w+,\s\w+\s\d{1,2},\s\d{4})`)
		returnDateExp := regexp.MustCompile(`Pickup\sperson\s=\s(\w+,\s\w+\s\d{1,2},\s\d{4})`)
		//otherEventDateExp := regexp.MustCompile(`Order\sComments\s=\s(.+)`)

		deliveryMatches := deliveryDateExp.FindStringSubmatch(integerString)
		//eventMatches := eventDateExp.FindStringSubmatch(integerString)
		collectionMatches := collectionDateExp.FindStringSubmatch(integerString)

		pickupDateMatches := pickupDateExp.FindStringSubmatch(integerString)
		returnDateMatches := returnDateExp.FindStringSubmatch(integerString)
		//otherEventDateMatches := otherEventDateExp.FindStringSubmatch(integerString)

		if len(deliveryMatches) < 2 && len(pickupDateMatches) < 2 {
			log.Fatalf("no pickup or delivery date for order %d, customer message %s", order.ID, order.CustomerMessage)
		}

		if len(collectionMatches) < 2 && len(returnDateMatches) < 2 {
			log.Fatalf("no collection or return date for order %d, customer message %s", order.ID, order.CustomerMessage)
		}

		startDate := ""
		if len(deliveryMatches) > 1 {
			startDate = deliveryMatches[1]
		}
		if len(pickupDateMatches) > 1 {
			startDate = pickupDateMatches[1]
		}

		if startDate == "" {
			log.Fatalf("no start date for order %d", order.ID)
		}

		endDate := ""
		if len(collectionMatches) > 1 {
			endDate = collectionMatches[1]
		}
		if len(returnDateMatches) > 1 {
			endDate = returnDateMatches[1]
		}

		if endDate == "" {
			log.Fatalf("no end date for order %d", order.ID)
		}

		var (
			page     = 1
			limit    = 50
			products = []bigcommerce.OrderProduct{}
		)
		for {
			batch, _, err := client.GetOrderProducts(order.ID, bigcommerce.OrderProductsQueryParams{Page: page, Limit: limit})
			if err != nil {
				log.Fatal(err)
			}
			products = append(products, batch...)
			if len(batch) < limit {
				break
			}
			page++
		}

		hirejob, err := ConvertOrderToHireJob(startDate, endDate, order, shippingAddress, products)
		if err != nil {
			log.Fatal(err)
		}

		b, err := xml.MarshalIndent(hirejob, "", "	")
		if err != nil {
			log.Fatal(err)
		}

		file, err := os.Create(fmt.Sprintf("order-%d.xml", order.ID))
		if err != nil {
			log.Fatal(err)
		}
		defer file.Close()

		_, err = file.Write(b)
		if err != nil {
			log.Fatal(err)
		}
	}
}
